<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenArm 3D Visualizer - xoq</title>
  <link rel="stylesheet" href="common.css" />
  <link rel="stylesheet" href="openarm.css" />
  <link rel="stylesheet" href="settings.css" />
</head>
<body>
  <script>
    (function() {
      var hasMSE = typeof MediaSource !== 'undefined';
      var hasWebCodecs = typeof VideoDecoder !== 'undefined';
      if (!hasMSE) {
        document.addEventListener('DOMContentLoaded', function() {
          var b = document.createElement('div');
          b.style.cssText = 'position:fixed;top:0;left:0;right:0;z-index:9999;background:#b91c1c;color:#fff;padding:8px 16px;text-align:center;font:14px/1.4 system-ui,sans-serif;';
          b.innerHTML = 'This browser does not support <b>MediaSource Extensions</b>. Color video playback requires MSE.';
          document.body.prepend(b);
        });
      } else if (!hasWebCodecs) {
        document.addEventListener('DOMContentLoaded', function() {
          var b = document.createElement('div');
          b.style.cssText = 'position:fixed;top:0;left:0;right:0;z-index:9999;background:#d97706;color:#fff;padding:8px 16px;text-align:center;font:14px/1.4 system-ui,sans-serif;';
          b.innerHTML = 'Depth and point cloud features are unavailable (WebCodecs not supported). Color video will work normally.';
          document.body.prepend(b);
        });
      }
    })();
  </script>
  <div class="top-bar">
    <div class="top-bar-main">
      <h1>OpenArm 3D</h1>
      <button id="startBtn">Connect</button>
      <button id="stopBtn" disabled>Disconnect</button>
      <button id="audioBtn" disabled title="Toggle audio playback">&#128263; Audio</button>
      <span id="audioLevel" style="color:#555; font-size:0.65rem; font-family:monospace; letter-spacing:-1px; white-space:nowrap;" title="Audio level (RMS)">--</span>
      <span id="statusText" style="color:#888; font-size:0.8rem;">Idle</span>
      <span id="viewerCount" style="color:#888; font-size:0.8rem; margin-left:0.25rem;">0 viewers</span>
      <span style="font-size:0.8rem; margin-left:0.25rem;" title="Video stream latency and FPS"><span id="streamPing" style="color:#555; display:inline-block; width:5.5em; text-align:right;">--</span> <span id="streamFps" style="color:#555; display:inline-block; width:3.5em; text-align:right;">--</span></span>
      <button id="settingsToggle" class="settings-toggle" aria-label="Settings">&#9881;</button>
    </div>
  </div>

  <div class="main">
    <div class="canvas-container" id="view3d">
      <canvas id="threeCanvas"></canvas>
      <div class="canvas-overlay">
        <span>Drag to orbit / Scroll to zoom / Right-drag to pan</span>
      </div>
    </div>
    <div class="camera-split" id="cameraSplit"></div>
    <div class="settings-panel" id="settingsPanel"></div>
    <div class="side-panel">
      <div id="armPanelsContainer"></div>
      <div class="panel-section" id="panelStats">
        <h3>Stats</h3>
        <div class="stats-grid">
          <div class="stat">
            <div class="stat-label">Frames</div>
            <div class="stat-value" id="frameCount">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Bytes</div>
            <div class="stat-value" id="bytesReceived">0 B</div>
          </div>
          <div class="stat">
            <div class="stat-label">FPS</div>
            <div class="stat-value" id="canFps">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Last</div>
            <div class="stat-value" id="lastUpdate">-</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-bar" id="tabBar">
    <button class="tab-btn active" data-tab="3d">3D</button>
    <button class="tab-btn" data-tab="arms">Arms</button>
    <button class="tab-btn" data-tab="camera">Cam</button>
    <button class="tab-btn" data-tab="stats">Stats</button>
    <button class="tab-btn" data-tab="log">Log</button>
    <button class="tab-btn" data-tab="settings">&#9881;</button>
  </div>

  <div class="log-panel" id="log"></div>
  <div class="chat-bar">
    <input type="text" id="chatUsername" placeholder="Name" readonly />
    <input type="text" id="chatInput" placeholder="Press Enter to send" value="hello world" />
  </div>
  <div class="toast-container" id="toasts"></div>

  <script type="module">
    import { loadConfig, saveConfig, flattenArmPairs } from "./openarm-config.js";
    import { initLog, log, setStatus } from "./openarm-log.js";
    import { makeJointState } from "./openarm-can.js";
    import { subscribeArm, connectRealSense, disconnectRealSense, connectCameras, disconnectCameras, startQueryLoopForPair, stopQueryLoopForPair, stopAllQueryLoops, enableArmTorque, disableArmTorque, disconnectAllCmdArms } from "./openarm-moq.js";
    import { createAudioState, connectAudio, disconnectAudio } from "./openarm-audio.js";
    import { createChatState, connectChat, disconnectChat, sendChatMessage } from "./openarm-chat.js";
    import { initScene, buildJointRows, updatePanel, startRenderLoop, setupDumpDepth, applyCamPoseFromConfig, makeTextSprite } from "./openarm-scene.js";
    import { initSettings } from "./openarm-settings.js";

    // ─── Config ──────────────────────────────────────
    const config = loadConfig({ urlOverrides: true });
    const armConfigs = flattenArmPairs(config);

    // ─── Init logging ────────────────────────────────
    const logEl = document.getElementById("log");
    const toastsEl = document.getElementById("toasts");
    const statusText = document.getElementById("statusText");
    initLog(logEl, toastsEl, statusText);

    // ─── Chat username (read-only, set from config) ──
    const chatUsernameInput = document.getElementById("chatUsername");
    chatUsernameInput.value = config.chat.username;

    // ─── Shared mutable state ────────────────────────
    const appState = {
      running: false,
      connections: [],
      frameCount: 0,
      bytesTotal: 0,
      fpsCounter: 0,
      lastFpsTime: performance.now(),
      latency: { ms: null, lastUpdate: 0, sum: 0, samples: 0, display: null },
      videoFps: { count: 0, value: null, lastTime: performance.now() },
    };

    const armStates = armConfigs.map(() => makeJointState());

    // Command publishing state (per arm)
    const cmdState = {};
    armConfigs.forEach(arm => { cmdState[arm.id] = { conn: null, broadcast: null, track: null, group: null }; });
    const queryIntervals = {}; // pairIdx → intervalId

    // Audio + chat state
    const audioState = createAudioState();
    const chatState = createChatState();
    function getUsername() { return chatUsernameInput.value.trim() || "Anon"; }

    // ─── Init scene ──────────────────────────────────
    const cameraSplitEl = document.getElementById("cameraSplit");
    const sceneHandle = initScene(config, armConfigs, cameraSplitEl);
    const { robots, robotGroups, grids, pointClouds, rsVideoEls, rsCams, rsCamGroups, camVideoEls, camState, onResize } = sceneHandle;

    // ─── Settings panel ─────────────────────────────
    const settingsPanel = document.getElementById("settingsPanel");
    const settingsToggle = document.getElementById("settingsToggle");
    let settingsOpen = false;

    const settingsHandle = initSettings(settingsPanel, config, {
      primaryButtonLabel: "Close Settings",
      onPrimaryAction() { toggleSettings(); },
      onLiveUpdate(type, index) {
        if (type === 'armPair' && robotGroups[index]) {
          const pair = config.armPairs[index];
          applyCamPoseFromConfig(robotGroups[index], pair);
          if (grids[index]) {
            const p = pair.position || {};
            grids[index].position.set(p.x || 0, p.y || 0, p.z || 0);
          }
          // Update label sprite (first child sprite)
          const oldLabel = robotGroups[index].children.find(c => c.isSprite);
          if (oldLabel) {
            robotGroups[index].remove(oldLabel);
            oldLabel.material.map.dispose();
            oldLabel.material.dispose();
          }
          const newLabel = makeTextSprite(pair.label || ("Arm Pair " + (index + 1)), "#00d4ff");
          newLabel.position.set(0, 0.85, 0);
          robotGroups[index].add(newLabel);
        }
        if (type === 'realsense' && rsCamGroups[index]) {
          const rs = config.realsense[index];
          applyCamPoseFromConfig(rsCamGroups[index], rs);
          // Update label
          const oldLabel = rsCamGroups[index].children.find(c => c.isSprite);
          if (oldLabel) {
            rsCamGroups[index].remove(oldLabel);
            oldLabel.material.map.dispose();
            oldLabel.material.dispose();
          }
          const newLabel = makeTextSprite(rs.label || ("RS " + (index + 1)), "#ff8c42");
          newLabel.position.set(0, 0.06, 0);
          rsCamGroups[index].add(newLabel);
          // Update point size
          if (pointClouds[index]) {
            pointClouds[index].material.size = (rs.pointSize || 2) * 0.001;
          }
        }
      },
      onStructuralChange() {
        log("Config saved. Reconnect to apply path/structure changes.", "info");
      },
    });

    function toggleSettings() {
      settingsOpen = !settingsOpen;
      settingsPanel.classList.toggle("active", settingsOpen);
      settingsToggle.classList.toggle("active", settingsOpen);
      cameraSplitEl.classList.toggle("settings-hidden", settingsOpen);
      if (settingsOpen) settingsHandle.renderAll();
      requestAnimationFrame(onResize);
    }

    settingsToggle.addEventListener("click", toggleSettings);

    // ─── Build arm panels with per-pair query + per-arm torque buttons ─
    const armJointEls = [];
    const armPanelEls = [];
    const queryBtns = {}; // pairIdx → button element
    const torqueBtns = {}; // armId → button element
    const armPanelsContainer = document.getElementById("armPanelsContainer");

    // Group arms by pair
    const pairIndices = [...new Set(armConfigs.map(a => a.pairIdx))];
    pairIndices.forEach(pairIdx => {
      const pair = config.armPairs[pairIdx];
      const pairArms = armConfigs.filter(a => a.pairIdx === pairIdx);

      // Pair header with query button
      const header = document.createElement("div");
      header.style.cssText = "display:flex; align-items:center; gap:0.5rem; padding:0.5rem 0.75rem 0; border-bottom:none;";
      header.innerHTML = `<span style="font-size:0.8rem; color:#888; text-transform:uppercase; font-weight:bold;">${pair.label || ("Arm Pair " + (pairIdx + 1))}</span>
        <span style="font-size:0.65rem; color:#555;">${pair.queryRate || 200}Hz</span>`;
      const qBtn = document.createElement("button");
      qBtn.className = "query-btn";
      qBtn.textContent = "Query";
      qBtn.disabled = true;
      qBtn.dataset.pair = pairIdx;
      header.appendChild(qBtn);
      armPanelsContainer.appendChild(header);
      queryBtns[pairIdx] = qBtn;

      // Per-arm sections within this pair
      pairArms.forEach(arm => {
        const idx = armConfigs.indexOf(arm);
        const section = document.createElement("div");
        section.className = "panel-section";
        section.id = "panelArm" + idx;

        const armHeader = document.createElement("div");
        armHeader.style.cssText = "display:flex; align-items:center; gap:0.5rem; margin-bottom:0.4rem;";
        armHeader.innerHTML = `<h3 style="margin:0;">${arm.label || ("Arm " + (idx + 1))}</h3>`;
        const tBtn = document.createElement("button");
        tBtn.className = "torque-btn";
        tBtn.textContent = "Torque";
        tBtn.disabled = true;
        tBtn.dataset.armId = arm.id;
        armHeader.appendChild(tBtn);
        section.appendChild(armHeader);
        torqueBtns[arm.id] = tBtn;

        const rows = document.createElement("div");
        rows.innerHTML = `<div class="joint-row" style="font-size:0.65rem; color:#666;">
            <span>Joint</span><span style="text-align:right;">Angle</span><span style="text-align:right;">Vel</span><span style="text-align:right;">Tau</span>
          </div>
          <div id="armJointRows${idx}"></div>`;
        section.appendChild(rows);

        armPanelsContainer.appendChild(section);
        armPanelEls.push(section);
        armJointEls.push(buildJointRows(section.querySelector(`#armJointRows${idx}`), "arm" + idx));
      });
    });

    // Query button click handlers (per pair)
    for (const [pairIdx, btn] of Object.entries(queryBtns)) {
      const pi = parseInt(pairIdx);
      btn.addEventListener("click", async () => {
        if (!queryIntervals[pi]) {
          btn.disabled = true;
          btn.textContent = "Starting...";
          try {
            const interval = await startQueryLoopForPair(config, pi, armConfigs, cmdState);
            if (interval) {
              queryIntervals[pi] = interval;
              btn.classList.add("active");
              btn.textContent = "Stop";
            } else {
              btn.textContent = "Query";
            }
            btn.disabled = false;
          } catch (e) {
            log(`Query start error: ${e.message}`, "error");
            btn.textContent = "Query";
            btn.disabled = false;
          }
        } else {
          stopQueryLoopForPair(queryIntervals[pi], pi, armConfigs, cmdState);
          delete queryIntervals[pi];
          btn.classList.remove("active");
          btn.textContent = "Query";
        }
      });
    }

    // Torque button click handlers (per arm)
    for (const [armId, btn] of Object.entries(torqueBtns)) {
      const arm = armConfigs.find(a => a.id === armId);
      if (!arm) continue;
      btn.addEventListener("click", async () => {
        const isActive = btn.classList.contains("active");
        btn.disabled = true;
        try {
          if (!isActive) {
            btn.textContent = "Enabling...";
            await enableArmTorque(config, armId, arm.path, cmdState);
            btn.classList.add("active");
            btn.textContent = "Torque ON";
          } else {
            btn.textContent = "Disabling...";
            await disableArmTorque(config, armId, arm.path, cmdState);
            btn.classList.remove("active");
            btn.textContent = "Torque";
          }
        } catch (e) {
          log(`[${armId}] Torque error: ${e.message}`, "error");
          btn.classList.remove("active");
          btn.textContent = "Torque";
        }
        btn.disabled = false;
      });
    }

    // ─── DOM refs ────────────────────────────────────
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const audioBtn = document.getElementById("audioBtn");

    // ─── Start render loop + debug ───────────────────
    startRenderLoop(sceneHandle, armStates);
    setupDumpDepth(rsCams);

    // ─── Audio toggle ────────────────────────────────
    audioBtn.addEventListener('click', () => {
      audioState.enabled = !audioState.enabled;
      if (audioState.enabled) {
        if (!audioState.audioCtx) {
          audioState.audioCtx = new AudioContext({ sampleRate: 48000 });
          audioState.nextPlayTime = 0;
          log(`[audio] AudioContext created: ${audioState.audioCtx.sampleRate}Hz`, 'data', { toast: false });
        }
        if (audioState.audioCtx.state === 'suspended') audioState.audioCtx.resume();
        audioBtn.classList.add('active');
        audioBtn.innerHTML = '&#128266; Audio';
        if (appState.running) connectAudio(config, audioState).catch(e => log(`[audio] ${e.message}`, 'error'));
      } else {
        audioBtn.classList.remove('active');
        audioBtn.innerHTML = '&#128263; Audio';
        disconnectAudio(audioState);
      }
    });

    // ─── Connect / Disconnect ────────────────────────
    startBtn.addEventListener("click", async () => {
      try {
        const hasArmPaths = armConfigs.some(a => a.enabled && (a.path || "").trim());
        const hasRsPaths = config.realsense.some(c => c.enabled !== false && (c.path || "").trim());
        const hasCamPaths = config.cameras.some(c => c.enabled !== false && (c.path || "").trim());
        if (!hasArmPaths && !hasRsPaths && !hasCamPaths) { log("No enabled paths configured — open Settings to add arm/camera paths", "error"); return; }

        startBtn.disabled = true;
        stopBtn.disabled = false;
        appState.running = true;
        appState.frameCount = 0;
        appState.bytesTotal = 0;
        appState.fpsCounter = 0;
        appState.connections = [];

        setStatus("Connecting...");
        log(`WebTransport: ${typeof WebTransport !== 'undefined' ? 'supported' : 'NOT supported'}`, "data", { toast: false });

        // Warn if duplicate arm paths
        const armPaths = armConfigs.map(a => (a.path || "").trim()).filter(Boolean);
        const dupPaths = armPaths.filter((p, i) => armPaths.indexOf(p) !== i);
        if (dupPaths.length) log(`WARNING: Multiple arms share path "${dupPaths[0]}" — cross-talk expected!`, "error");

        const subs = [];

        // Subscribe to enabled arms
        armConfigs.forEach((arm, idx) => {
          const path = (arm.path || "").trim();
          if (arm.enabled && path) subs.push(subscribeArm(config, appState, arm.id, path, armStates[idx]).catch(e => log(`[${arm.id}] ${e.message}`, "error")));
        });

        // Connect RealSense cameras
        if (hasRsPaths) subs.push(connectRealSense(config, appState, rsCams, rsVideoEls).catch(e => log(`[realsense] ${e.message}`, "error")));

        // Connect plain cameras
        if (hasCamPaths) subs.push(connectCameras(config, camState, camVideoEls).catch(e => log(`[camera] ${e.message}`, "error")));

        // Connect chat (if enabled)
        if (config.chat.enabled !== false) {
          subs.push(connectChat(config, chatState, getUsername, toastsEl).catch(e => log(`[chat] ${e.message}`, "error")));
        }

        // Enable audio button (if audio enabled in config) + query buttons + torque buttons
        if (config.audio.enabled !== false) audioBtn.disabled = false;
        for (const [pi, btn] of Object.entries(queryBtns)) {
          const pairArms = armConfigs.filter(a => a.pairIdx === parseInt(pi));
          if (pairArms.some(a => a.enabled && (a.path || "").trim())) btn.disabled = false;
        }
        for (const [armId, btn] of Object.entries(torqueBtns)) {
          const arm = armConfigs.find(a => a.id === armId);
          if (arm && arm.enabled && (arm.path || "").trim()) btn.disabled = false;
        }

        // Auto-start query for enabled pairs with autoQuery
        for (const [pi, btn] of Object.entries(queryBtns)) {
          const pairIdx = parseInt(pi);
          const pair = config.armPairs[pairIdx];
          if (pair && pair.enabled !== false && pair.autoQuery) {
            const pairArms = armConfigs.filter(a => a.pairIdx === pairIdx);
            if (pairArms.some(a => a.enabled && (a.path || "").trim())) {
              startQueryLoopForPair(config, pairIdx, armConfigs, cmdState).then(interval => {
                if (interval) {
                  queryIntervals[pairIdx] = interval;
                  btn.classList.add("active");
                  btn.textContent = "Stop";
                }
              }).catch(e => log(`Query auto-start error: ${e.message}`, "error"));
            }
          }
        }

        // Connect audio if enabled (user previously toggled it on)
        if (audioState.enabled) {
          if (!audioState.audioCtx) {
            audioState.audioCtx = new AudioContext({ sampleRate: 48000 });
            audioState.nextPlayTime = 0;
          }
          if (audioState.audioCtx.state === 'suspended') audioState.audioCtx.resume();
          subs.push(connectAudio(config, audioState).catch(e => log(`[audio] ${e.message}`, 'error')));
        }

        setStatus("Streaming");

        await Promise.all(subs);
        setStatus("Ended");
      } catch (e) {
        log(`Error: ${e.message}`, "error");
        console.error(e);
        setStatus("Error");
      } finally {
        // Stop all query loops + disconnect command channels
        stopAllQueryLoops(queryIntervals);
        for (const k of Object.keys(queryIntervals)) delete queryIntervals[k];
        disconnectAllCmdArms(armConfigs, cmdState);
        for (const btn of Object.values(queryBtns)) {
          btn.classList.remove("active");
          btn.textContent = "Query";
          btn.disabled = true;
        }
        for (const btn of Object.values(torqueBtns)) {
          btn.classList.remove("active");
          btn.textContent = "Torque";
          btn.disabled = true;
        }
        disconnectRealSense(rsCams, pointClouds);
        disconnectCameras(camState);
        disconnectChat(chatState);
        disconnectAudio(audioState);
        audioBtn.disabled = true;
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    });

    stopBtn.addEventListener("click", async () => {
      appState.running = false;
      // Stop all query loops + disconnect command channels
      stopAllQueryLoops(queryIntervals);
      for (const k of Object.keys(queryIntervals)) delete queryIntervals[k];
      disconnectAllCmdArms(armConfigs, cmdState);
      for (const btn of Object.values(queryBtns)) {
        btn.classList.remove("active");
        btn.textContent = "Query";
        btn.disabled = true;
      }
      for (const btn of Object.values(torqueBtns)) {
        btn.classList.remove("active");
        btn.textContent = "Torque";
        btn.disabled = true;
      }
      setStatus("Stopping...");
      disconnectRealSense(rsCams, pointClouds);
      disconnectCameras(camState);
      disconnectChat(chatState);
      disconnectAudio(audioState);
      appState.latency.ms = null;
      appState.latency.lastUpdate = 0;
      appState.latency.sum = 0;
      appState.latency.samples = 0;
      appState.latency.display = null;
      appState.videoFps.count = 0;
      appState.videoFps.value = null;
      audioBtn.disabled = true;
      for (const conn of appState.connections) { try { conn.close(); } catch (e) {} }
      appState.connections = [];
      startBtn.disabled = false;
      stopBtn.disabled = true;
      setStatus("Disconnected");
      log("Disconnected", "success");
    });

    // Chat input
    document.getElementById('chatInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendChatMessage(e.target.value, chatState, getUsername, toastsEl);
        e.target.value = '';
      }
    });

    // Periodic panel update
    setInterval(() => updatePanel(armStates, armJointEls, appState), 100);

    log("Ready. Click Connect to start.", "info");

    // Auto-connect on page load
    setTimeout(() => startBtn.click(), 500);

    // ─── Tab switching ───────────────────────────────
    const tabBar = document.getElementById('tabBar');
    const sidePanel = document.querySelector('.side-panel');
    const logPanel = document.getElementById('log');
    const cameraSplit = document.getElementById('cameraSplit');
    const view3dEl = document.getElementById('view3d');
    const panelMap = {
      arms: armPanelEls,
      stats: [document.getElementById('panelStats')],
    };
    const allPanels = Object.values(panelMap).flat();

    tabBar.addEventListener('click', (e) => {
      const btn = e.target.closest('.tab-btn');
      if (!btn) return;
      const tab = btn.dataset.tab;

      tabBar.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      sidePanel.classList.remove('tab-visible');
      allPanels.forEach(p => p.classList.remove('tab-visible'));
      logPanel.classList.remove('tab-visible');
      cameraSplit.classList.remove('tab-visible');
      settingsPanel.classList.remove('tab-visible');
      view3dEl.style.display = '';

      if (tab === '3d') {
        requestAnimationFrame(onResize);
      } else if (tab === 'log') {
        logPanel.classList.add('tab-visible');
        view3dEl.style.display = 'none';
      } else if (tab === 'camera') {
        cameraSplit.classList.add('tab-visible');
        view3dEl.style.display = 'none';
      } else if (tab === 'settings') {
        settingsPanel.classList.add('tab-visible');
        settingsHandle.renderAll();
        view3dEl.style.display = 'none';
      } else if (tab in panelMap) {
        sidePanel.classList.add('tab-visible');
        panelMap[tab].forEach(p => p.classList.add('tab-visible'));
        view3dEl.style.display = 'none';
      }
    });
  </script>
</body>
</html>
