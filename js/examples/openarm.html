<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenArm 3D Visualizer - xoq</title>
  <link rel="stylesheet" href="common.css" />
  <link rel="stylesheet" href="openarm.css" />
  <link rel="stylesheet" href="settings.css" />
</head>
<body>
  <script>
    (function() {
      var hasMSE = typeof MediaSource !== 'undefined';
      var hasWebCodecs = typeof VideoDecoder !== 'undefined';
      if (!hasMSE) {
        document.addEventListener('DOMContentLoaded', function() {
          var b = document.createElement('div');
          b.style.cssText = 'position:fixed;top:0;left:0;right:0;z-index:9999;background:#b91c1c;color:#fff;padding:8px 16px;text-align:center;font:14px/1.4 system-ui,sans-serif;';
          b.innerHTML = 'This browser does not support <b>MediaSource Extensions</b>. Color video playback requires MSE.';
          document.body.prepend(b);
        });
      } else if (!hasWebCodecs) {
        document.addEventListener('DOMContentLoaded', function() {
          var b = document.createElement('div');
          b.style.cssText = 'position:fixed;top:0;left:0;right:0;z-index:9999;background:#d97706;color:#fff;padding:8px 16px;text-align:center;font:14px/1.4 system-ui,sans-serif;';
          b.innerHTML = 'Depth and point cloud features are unavailable (WebCodecs not supported). Color video will work normally.';
          document.body.prepend(b);
        });
      }
    })();
  </script>
  <div class="top-bar">
    <div class="top-bar-main">
      <h1>OpenArm 3D</h1>
      <button id="startBtn">Connect</button>
      <button id="stopBtn" disabled>Disconnect</button>
      <button id="audioBtn" disabled title="Toggle audio playback">&#128263; Audio</button>
      <button id="recordBtn" disabled title="Record live streams to MP4 files"><span class="rec-dot"></span> Record</button>
      <button id="replayBtn" title="Replay a recorded .mp4 file">Replay</button>
      <input type="file" id="replayFile" accept=".mp4,.bin,.log" multiple style="display:none" />
      <span id="audioLevel" style="color:#555; font-size:0.65rem; font-family:monospace; letter-spacing:-1px; white-space:nowrap;" title="Audio level (RMS)">--</span>
      <span id="statusText" style="color:#888; font-size:0.8rem;">Idle</span>
      <span id="viewerCount" style="color:#888; font-size:0.8rem; margin-left:0.25rem;">0 viewers</span>
      <span style="font-size:0.8rem; margin-left:0.25rem;" title="Video stream latency and FPS"><span id="streamPing" style="color:#555; display:inline-block; width:5.5em; text-align:right;">--</span> <span id="streamFps" style="color:#555; display:inline-block; width:3.5em; text-align:right;">--</span></span>
      <button id="settingsToggle" class="settings-toggle" aria-label="Settings">&#9881;</button>
    </div>
  </div>

  <div class="replay-bar" id="replayBar">
    <button id="replayPlayPause">Play</button>
    <span class="replay-time" id="replayCurrentTime">0:00</span>
    <input type="range" id="replayTimeline" min="0" max="1000" value="0" step="1" />
    <span class="replay-time" id="replayDuration">0:00</span>
    <select id="replaySpeed">
      <option value="0.25">0.25x</option>
      <option value="0.5">0.5x</option>
      <option value="1" selected>1x</option>
      <option value="2">2x</option>
      <option value="4">4x</option>
    </select>
    <button id="replayClose">X</button>
  </div>

  <div class="main">
    <div class="canvas-container" id="view3d">
      <canvas id="threeCanvas"></canvas>
      <div class="canvas-overlay">
        <span>Drag to orbit / Scroll to zoom / Right-drag to pan</span>
      </div>
    </div>
    <div class="camera-split" id="cameraSplit"></div>
    <div class="settings-panel" id="settingsPanel"></div>
    <div class="side-panel">
      <div id="armPanelsContainer"></div>
      <div class="panel-section" id="panelStats">
        <h3>Stats</h3>
        <div class="stats-grid">
          <div class="stat">
            <div class="stat-label">Frames</div>
            <div class="stat-value" id="frameCount">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Bytes</div>
            <div class="stat-value" id="bytesReceived">0 B</div>
          </div>
          <div class="stat">
            <div class="stat-label">FPS</div>
            <div class="stat-value" id="canFps">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Last</div>
            <div class="stat-value" id="lastUpdate">-</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-bar" id="tabBar">
    <button class="tab-btn active" data-tab="3d">3D</button>
    <button class="tab-btn" data-tab="arms">Arms</button>
    <button class="tab-btn" data-tab="camera">Cam</button>
    <button class="tab-btn" data-tab="stats">Stats</button>
    <button class="tab-btn" data-tab="log">Log</button>
    <button class="tab-btn" data-tab="settings">&#9881;</button>
  </div>

  <div class="log-panel" id="log"></div>
  <div class="chat-bar">
    <input type="text" id="chatUsername" placeholder="Name" readonly />
    <input type="text" id="chatInput" placeholder="Press Enter to send" value="hello world" />
  </div>
  <div class="toast-container" id="toasts"></div>

  <script type="module">
    import { loadConfig, saveConfig, flattenArmPairs } from "./openarm-config.js";
    import { initLog, log, setStatus } from "./openarm-log.js";
    import { makeJointState } from "./openarm-can.js";
    import { subscribeArm, connectRealSense, disconnectRealSense, connectCameras, disconnectCameras } from "./openarm-moq.js";
    import { createAudioState, connectAudio, disconnectAudio } from "./openarm-audio.js";
    import { createChatState, connectChat, disconnectChat, sendChatMessage } from "./openarm-chat.js";
    import { initScene, buildJointRows, updatePanel, startRenderLoop, setupDumpDepth, applyCamPoseFromConfig, makeTextSprite, labelWithTags } from "./openarm-scene.js";
    import { initSettings } from "./openarm-settings.js";
    import { createReplayController } from "./openarm-replay.js";
    import { RecordingController } from "./openarm-recorder.js";

    // ─── Config ──────────────────────────────────────
    const config = loadConfig({ urlOverrides: true });
    const armConfigs = flattenArmPairs(config);

    // ─── Init logging ────────────────────────────────
    const logEl = document.getElementById("log");
    const toastsEl = document.getElementById("toasts");
    const statusText = document.getElementById("statusText");
    initLog(logEl, toastsEl, statusText);

    // ─── Chat username (read-only, set from config) ──
    const chatUsernameInput = document.getElementById("chatUsername");
    chatUsernameInput.value = config.chat.username;

    // ─── Shared mutable state ────────────────────────
    const appState = {
      running: false,
      connections: [],
      frameCount: 0,
      bytesTotal: 0,
      fpsCounter: 0,
      lastFpsTime: performance.now(),
      latency: { ms: null, lastUpdate: 0, sum: 0, samples: 0, display: null },
      videoFps: { count: 0, value: null, lastTime: performance.now() },
    };

    const armStates = armConfigs.map(() => makeJointState());

    // Audio + chat state
    const audioState = createAudioState();
    const chatState = createChatState();
    function getUsername() { return chatUsernameInput.value.trim() || "Anon"; }

    // ─── Init scene ──────────────────────────────────
    const cameraSplitEl = document.getElementById("cameraSplit");
    const sceneHandle = initScene(config, armConfigs, cameraSplitEl);
    const { robots, robotGroups, grids, pointClouds, rsVideoEls, rsCams, rsCamGroups, camVideoEls, camState, onResize } = sceneHandle;
    window._rsCams = rsCams; // debug: expose for diagnostics
    window._pointClouds = pointClouds;

    // Apply initial enabled/disabled visibility
    config.armPairs.forEach((pair, i) => {
      const vis = pair.enabled !== false;
      if (robotGroups[i]) robotGroups[i].visible = vis;
      if (grids[i]) grids[i].visible = vis;
    });
    config.realsense.forEach((rs, i) => {
      const vis = rs.enabled !== false;
      if (rsCamGroups[i]) rsCamGroups[i].visible = vis;
      const feedEl = rsVideoEls[i] && rsVideoEls[i].parentElement;
      if (feedEl) feedEl.style.display = vis ? "" : "none";
    });
    config.cameras.forEach((cam, i) => {
      const vis = cam.enabled !== false;
      const feedEl = camVideoEls[i] && camVideoEls[i].parentElement;
      if (feedEl) feedEl.style.display = vis ? "" : "none";
    });

    // ─── Settings panel ─────────────────────────────
    const settingsPanel = document.getElementById("settingsPanel");
    const settingsToggle = document.getElementById("settingsToggle");
    let settingsOpen = false;

    const settingsHandle = initSettings(settingsPanel, config, {
      primaryButtonLabel: "Close Settings",
      onPrimaryAction() { toggleSettings(); },
      onLiveUpdate(type, index) {
        if (type === 'armPair' && robotGroups[index]) {
          const pair = config.armPairs[index];
          applyCamPoseFromConfig(robotGroups[index], pair);
          if (grids[index]) {
            const p = pair.position || {};
            grids[index].position.set(p.x || 0, p.y || 0, p.z || 0);
          }
          // Update label sprite (first child sprite)
          const oldLabel = robotGroups[index].children.find(c => c.isSprite);
          if (oldLabel) {
            robotGroups[index].remove(oldLabel);
            oldLabel.material.map.dispose();
            oldLabel.material.dispose();
          }
          const newLabel = makeTextSprite(labelWithTags(pair.label || ("Arm Pair " + (index + 1)), pair.tags), "#00d4ff");
          newLabel.position.set(0, 0.85, 0);
          robotGroups[index].add(newLabel);
        }
        if (type === 'realsense' && rsCamGroups[index]) {
          const rs = config.realsense[index];
          applyCamPoseFromConfig(rsCamGroups[index], rs);
          // Update label
          const oldLabel = rsCamGroups[index].children.find(c => c.isSprite);
          if (oldLabel) {
            rsCamGroups[index].remove(oldLabel);
            oldLabel.material.map.dispose();
            oldLabel.material.dispose();
          }
          const newLabel = makeTextSprite(labelWithTags(rs.label || ("RS " + (index + 1)), rs.tags), "#ff8c42");
          newLabel.position.set(0, 0.06, 0);
          rsCamGroups[index].add(newLabel);
          // Update point size
          if (pointClouds[index]) {
            pointClouds[index].material.size = (rs.pointSize || 2) * 0.001;
          }
        }
      },
      onStructuralChange() {
        // Live-update visibility of 3D objects based on enabled state
        config.armPairs.forEach((pair, i) => {
          const vis = pair.enabled !== false;
          if (robotGroups[i]) robotGroups[i].visible = vis;
          if (grids[i]) grids[i].visible = vis;
        });
        config.realsense.forEach((rs, i) => {
          const vis = rs.enabled !== false;
          if (rsCamGroups[i]) rsCamGroups[i].visible = vis;
          const feedEl = rsVideoEls[i] && rsVideoEls[i].parentElement;
          if (feedEl) feedEl.style.display = vis ? "" : "none";
        });
        config.cameras.forEach((cam, i) => {
          const vis = cam.enabled !== false;
          const feedEl = camVideoEls[i] && camVideoEls[i].parentElement;
          if (feedEl) feedEl.style.display = vis ? "" : "none";
        });
        log("Config saved. Disconnect and reconnect to apply path changes.", "info");
      },
    });

    function toggleSettings() {
      settingsOpen = !settingsOpen;
      settingsPanel.classList.toggle("active", settingsOpen);
      settingsToggle.classList.toggle("active", settingsOpen);
      cameraSplitEl.classList.toggle("settings-hidden", settingsOpen);
      if (settingsOpen) settingsHandle.renderAll();
      requestAnimationFrame(onResize);
    }

    settingsToggle.addEventListener("click", toggleSettings);

    // ─── Build arm panels ─
    const armJointEls = [];
    const armPanelEls = [];
    const armPanelsContainer = document.getElementById("armPanelsContainer");

    // Group arms by pair
    const pairIndices = [...new Set(armConfigs.map(a => a.pairIdx))];
    pairIndices.forEach(pairIdx => {
      const pair = config.armPairs[pairIdx];
      const pairArms = armConfigs.filter(a => a.pairIdx === pairIdx);

      // Pair header
      const header = document.createElement("div");
      header.style.cssText = "display:flex; align-items:center; gap:0.5rem; padding:0.5rem 0.75rem 0; border-bottom:none;";
      header.innerHTML = `<span style="font-size:0.8rem; color:#888; text-transform:uppercase; font-weight:bold;">${pair.label || ("Arm Pair " + (pairIdx + 1))}</span>`;
      armPanelsContainer.appendChild(header);

      // Per-arm sections within this pair
      pairArms.forEach(arm => {
        const idx = armConfigs.indexOf(arm);
        const section = document.createElement("div");
        section.className = "panel-section";
        section.id = "panelArm" + idx;

        const armHeader = document.createElement("div");
        armHeader.style.cssText = "display:flex; align-items:center; gap:0.5rem; margin-bottom:0.4rem;";
        armHeader.innerHTML = `<h3 style="margin:0;">${arm.label || ("Arm " + (idx + 1))}</h3>`;
        section.appendChild(armHeader);

        const rows = document.createElement("div");
        rows.innerHTML = `<div class="joint-row" style="font-size:0.65rem; color:#666;">
            <span>Joint</span><span style="text-align:right;">Angle</span><span style="text-align:right;">Vel</span><span style="text-align:right;">Tau</span>
          </div>
          <div id="armJointRows${idx}"></div>`;
        section.appendChild(rows);

        armPanelsContainer.appendChild(section);
        armPanelEls.push(section);
        armJointEls.push(buildJointRows(section.querySelector(`#armJointRows${idx}`), "arm" + idx));
      });
    });

    // ─── DOM refs ────────────────────────────────────
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const audioBtn = document.getElementById("audioBtn");
    const recordBtn = document.getElementById("recordBtn");

    // ─── Start render loop + debug ───────────────────
    startRenderLoop(sceneHandle, armStates, config);
    setupDumpDepth(rsCams);

    // ─── Audio toggle ────────────────────────────────
    audioBtn.addEventListener('click', () => {
      audioState.enabled = !audioState.enabled;
      if (audioState.enabled) {
        if (!audioState.audioCtx) {
          audioState.audioCtx = new AudioContext({ sampleRate: 48000 });
          audioState.nextPlayTime = 0;
          log(`[audio] AudioContext created: ${audioState.audioCtx.sampleRate}Hz`, 'data', { toast: false });
        }
        if (audioState.audioCtx.state === 'suspended') audioState.audioCtx.resume();
        audioBtn.classList.add('active');
        audioBtn.innerHTML = '&#128266; Audio';
        if (appState.running) connectAudio(config, audioState).catch(e => log(`[audio] ${e.message}`, 'error'));
      } else {
        audioBtn.classList.remove('active');
        audioBtn.innerHTML = '&#128263; Audio';
        disconnectAudio(audioState);
      }
    });

    // ─── Record toggle ─────────────────────────────────
    recordBtn.addEventListener('click', () => {
      if (appState.recorder?.recording) {
        appState.recorder.stop();
        recordBtn.innerHTML = '<span class="rec-dot"></span> Record';
        recordBtn.classList.remove('recording');
      } else if (appState.recorder) {
        appState.recorder.start();
        recordBtn.innerHTML = '<span class="rec-dot"></span> Stop';
        recordBtn.classList.add('recording');
      }
    });

    // ─── Connect / Disconnect ────────────────────────
    startBtn.addEventListener("click", async () => {
      try {
        // Re-read arm configs from current settings (paths may have changed)
        const liveArmConfigs = flattenArmPairs(config);

        const hasArmPaths = liveArmConfigs.some(a => a.enabled && (a.path || "").trim());
        const hasRsPaths = config.realsense.some(c => c.enabled !== false && (c.path || "").trim());
        const hasCamPaths = config.cameras.some(c => c.enabled !== false && (c.path || "").trim());
        if (!hasArmPaths && !hasRsPaths && !hasCamPaths) { log("No enabled paths configured — open Settings to add arm/camera paths", "error"); return; }

        startBtn.disabled = true;
        stopBtn.disabled = false;
        recordBtn.disabled = false;
        appState.recorder = new RecordingController();
        appState.running = true;
        appState.frameCount = 0;
        appState.bytesTotal = 0;
        appState.fpsCounter = 0;
        appState.connections = [];

        setStatus("Connecting...");
        log(`WebTransport: ${typeof WebTransport !== 'undefined' ? 'supported' : 'NOT supported'}`, "data", { toast: false });

        // Warn if duplicate arm paths
        const armPaths = liveArmConfigs.map(a => (a.path || "").trim()).filter(Boolean);
        const dupPaths = armPaths.filter((p, i) => armPaths.indexOf(p) !== i);
        if (dupPaths.length) log(`WARNING: Multiple arms share path "${dupPaths[0]}" — cross-talk expected!`, "error");

        const subs = [];

        // Subscribe to enabled arms
        liveArmConfigs.forEach((arm, idx) => {
          const path = (arm.path || "").trim();
          if (arm.enabled && path) subs.push(subscribeArm(config, appState, arm.id, path, armStates[idx]).catch(e => log(`[${arm.id}] ${e.message}`, "error")));
        });

        // Connect RealSense cameras
        if (hasRsPaths) subs.push(connectRealSense(config, appState, rsCams, rsVideoEls).catch(e => log(`[realsense] ${e.message}`, "error")));

        // Connect plain cameras
        if (hasCamPaths) subs.push(connectCameras(config, appState, camState, camVideoEls).catch(e => log(`[camera] ${e.message}`, "error")));

        // Connect chat (if enabled)
        if (config.chat.enabled !== false) {
          subs.push(connectChat(config, chatState, getUsername, toastsEl).catch(e => log(`[chat] ${e.message}`, "error")));
        }

        // Enable audio button (if audio enabled in config)
        if (config.audio.enabled !== false) audioBtn.disabled = false;

        // Connect audio if enabled (user previously toggled it on)
        if (audioState.enabled) {
          if (!audioState.audioCtx) {
            audioState.audioCtx = new AudioContext({ sampleRate: 48000 });
            audioState.nextPlayTime = 0;
          }
          if (audioState.audioCtx.state === 'suspended') audioState.audioCtx.resume();
          subs.push(connectAudio(config, audioState).catch(e => log(`[audio] ${e.message}`, 'error')));
        }

        setStatus("Streaming");

        await Promise.all(subs);
        setStatus("Ended");
      } catch (e) {
        log(`Error: ${e.message}`, "error");
        console.error(e);
        setStatus("Error");
      } finally {
        disconnectRealSense(rsCams, pointClouds);
        disconnectCameras(camState);
        disconnectChat(chatState);
        disconnectAudio(audioState);
        if (appState.recorder?.recording) {
          appState.recorder.stop();
          recordBtn.innerHTML = '<span class="rec-dot"></span> Record';
          recordBtn.classList.remove('recording');
        }
        appState.recorder = null;
        audioBtn.disabled = true;
        recordBtn.disabled = true;
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    });

    stopBtn.addEventListener("click", async () => {
      appState.running = false;
      setStatus("Stopping...");
      disconnectRealSense(rsCams, pointClouds);
      disconnectCameras(camState);
      disconnectChat(chatState);
      disconnectAudio(audioState);
      appState.latency.ms = null;
      appState.latency.lastUpdate = 0;
      appState.latency.sum = 0;
      appState.latency.samples = 0;
      appState.latency.display = null;
      appState.videoFps.count = 0;
      appState.videoFps.value = null;
      if (appState.recorder?.recording) {
        appState.recorder.stop();
        recordBtn.innerHTML = '<span class="rec-dot"></span> Record';
        recordBtn.classList.remove('recording');
      }
      appState.recorder = null;
      audioBtn.disabled = true;
      recordBtn.disabled = true;
      for (const conn of appState.connections) { try { conn.close(); } catch (e) {} }
      appState.connections = [];
      startBtn.disabled = false;
      stopBtn.disabled = true;
      setStatus("Disconnected");
      log("Disconnected", "success");
    });

    // Chat input
    document.getElementById('chatInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendChatMessage(e.target.value, chatState, getUsername, toastsEl);
        e.target.value = '';
      }
    });

    // Periodic panel update
    setInterval(() => updatePanel(armStates, armJointEls, appState), 100);

    // ─── Replay ───────────────────────────────────────
    let replayController = null;
    const replayBtn = document.getElementById("replayBtn");
    const replayFile = document.getElementById("replayFile");
    const replayBar = document.getElementById("replayBar");
    const replayPlayPause = document.getElementById("replayPlayPause");
    const replayTimeline = document.getElementById("replayTimeline");
    const replayCurrentTime = document.getElementById("replayCurrentTime");
    const replayDuration = document.getElementById("replayDuration");
    const replaySpeed = document.getElementById("replaySpeed");
    const replayClose = document.getElementById("replayClose");

    function formatReplayTime(ms) {
      const s = Math.floor(ms / 1000);
      const m = Math.floor(s / 60);
      return `${m}:${(s % 60).toString().padStart(2, '0')}`;
    }

    replayBtn.addEventListener("click", () => {
      if (replayController) return; // already in replay mode
      replayFile.click();
    });

    replayFile.addEventListener("change", async () => {
      const files = Array.from(replayFile.files);
      if (files.length === 0) return;
      replayFile.value = ""; // reset for re-selection

      // Disconnect live streams if running
      if (appState.running) {
        appState.running = false;
        disconnectRealSense(rsCams, pointClouds);
        disconnectCameras(camState);
        disconnectChat(chatState);
        disconnectAudio(audioState);
        if (appState.recorder?.recording) {
          appState.recorder.stop();
          recordBtn.innerHTML = '<span class="rec-dot"></span> Record';
          recordBtn.classList.remove('recording');
        }
        appState.recorder = null;
        for (const conn of appState.connections) { try { conn.close(); } catch (e) {} }
        appState.connections = [];
      }

      // Disable live buttons
      startBtn.disabled = true;
      stopBtn.disabled = true;
      audioBtn.disabled = true;
      recordBtn.disabled = true;
      replayBtn.classList.add("active");

      // Create replay controller
      replayController = createReplayController({
        armStates, rsCams, rsVideoEls, pointClouds, appState, config,
      });

      try {
        setStatus("Loading replay...");
        if (files.length === 1) {
          await replayController.loadFile(files[0]);
        } else {
          await replayController.loadFiles(files);
        }

        // Show replay bar
        replayBar.classList.add("active");
        replayDuration.textContent = formatReplayTime(replayController.durationMs);
        replayCurrentTime.textContent = "0:00";
        replayTimeline.value = 0;
        replayPlayPause.textContent = "Play";

        // Wire time update
        replayController.onTimeUpdate = (timeMs) => {
          replayCurrentTime.textContent = formatReplayTime(timeMs);
          if (replayController.durationMs > 0) {
            replayTimeline.value = Math.round((timeMs / replayController.durationMs) * 1000);
          }
        };

        replayController.onEnded = () => {
          replayPlayPause.textContent = "Play";
        };

        setStatus("Replay loaded");
        log("Replay ready. Press Play.", "success");
      } catch (e) {
        log(`Replay error: ${e.message}`, "error");
        console.error(e);
        closeReplay();
      }
    });

    replayPlayPause.addEventListener("click", () => {
      if (!replayController) return;
      if (replayController.playing) {
        replayController.pause();
        replayPlayPause.textContent = "Play";
      } else {
        replayController.play();
        replayPlayPause.textContent = "Pause";
      }
    });

    replayTimeline.addEventListener("input", () => {
      if (!replayController) return;
      const frac = parseInt(replayTimeline.value) / 1000;
      const timeMs = frac * replayController.durationMs;
      replayController.seek(timeMs);
      replayCurrentTime.textContent = formatReplayTime(timeMs);
    });

    replaySpeed.addEventListener("change", () => {
      if (!replayController) return;
      replayController.setSpeed(parseFloat(replaySpeed.value));
    });

    function closeReplay() {
      if (replayController) {
        replayController.destroy();
        replayController = null;
      }
      replayBar.classList.remove("active");
      replayBtn.classList.remove("active");
      startBtn.disabled = false;
      stopBtn.disabled = true;
      audioBtn.disabled = true;
      replayPlayPause.textContent = "Play";
      replayTimeline.value = 0;
      replayCurrentTime.textContent = "0:00";
      replayDuration.textContent = "0:00";
      setStatus("Idle");
    }

    replayClose.addEventListener("click", closeReplay);

    log("Ready. Click Connect to start.", "info");

    // Auto-connect on page load
    setTimeout(() => startBtn.click(), 500);

    // ─── Tab switching ───────────────────────────────
    const tabBar = document.getElementById('tabBar');
    const sidePanel = document.querySelector('.side-panel');
    const logPanel = document.getElementById('log');
    const cameraSplit = document.getElementById('cameraSplit');
    const view3dEl = document.getElementById('view3d');
    const panelMap = {
      arms: armPanelEls,
      stats: [document.getElementById('panelStats')],
    };
    const allPanels = Object.values(panelMap).flat();

    tabBar.addEventListener('click', (e) => {
      const btn = e.target.closest('.tab-btn');
      if (!btn) return;
      const tab = btn.dataset.tab;

      tabBar.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      sidePanel.classList.remove('tab-visible');
      allPanels.forEach(p => p.classList.remove('tab-visible'));
      logPanel.classList.remove('tab-visible');
      cameraSplit.classList.remove('tab-visible');
      settingsPanel.classList.remove('tab-visible');
      view3dEl.style.display = '';

      if (tab === '3d') {
        requestAnimationFrame(onResize);
      } else if (tab === 'log') {
        logPanel.classList.add('tab-visible');
        view3dEl.style.display = 'none';
      } else if (tab === 'camera') {
        cameraSplit.classList.add('tab-visible');
        view3dEl.style.display = 'none';
      } else if (tab === 'settings') {
        settingsPanel.classList.add('tab-visible');
        settingsHandle.renderAll();
        view3dEl.style.display = 'none';
      } else if (tab in panelMap) {
        sidePanel.classList.add('tab-visible');
        panelMap[tab].forEach(p => p.classList.add('tab-visible'));
        view3dEl.style.display = 'none';
      }
    });
  </script>
</body>
</html>
