//! Disable torque on OpenArm motors via iroh P2P.
//!
//! Reads server IDs from ~/.config/xoq/machines.json (generated by fetch-machines.sh).
//! Sends the Damiao DISABLE_MIT command to all 8 motors on each arm.
//!
//! Usage:
//!   cargo run --example openarm_disable --features=can-remote
//!   cargo run --example openarm_disable --features=can-remote -- baguette
//!   cargo run --example openarm_disable --features=can-remote -- champagne left

use anyhow::Result;
use std::time::Duration;
use xoq::socketcan;

extern crate serde_json;

const DISABLE_MIT: [u8; 8] = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD];

#[derive(Debug)]
struct Arm {
    label: String,
    node_id: String,
}

fn load_arms(filter_host: Option<&str>, filter_side: Option<&str>) -> Result<Vec<Arm>> {
    // Check ~/.config/xoq first (where fetch-machines.sh writes), then platform default
    let home = std::env::var("HOME").unwrap_or_default();
    let config_path = std::path::PathBuf::from(&home).join(".config/xoq/machines.json");

    let data = std::fs::read_to_string(&config_path).map_err(|e| {
        anyhow::anyhow!(
            "Cannot read {}: {}. Run scripts/fetch-machines.sh first.",
            config_path.display(),
            e
        )
    })?;

    let machines: Vec<serde_json::Value> = serde_json::from_str(&data)?;
    let mut arms = Vec::new();

    for machine in &machines {
        let hostname = machine["hostname"]
            .as_str()
            .unwrap_or("unknown")
            .to_string();
        let short_name = hostname.split('-').next().unwrap_or(&hostname);

        if let Some(host) = filter_host {
            if !short_name.eq_ignore_ascii_case(host) {
                continue;
            }
        }

        if let Some(cans) = machine["services"]["can"].as_array() {
            for (i, can) in cans.iter().enumerate() {
                let side = if i == 0 { "left" } else { "right" };
                if let Some(s) = filter_side {
                    if !side.eq_ignore_ascii_case(s) {
                        continue;
                    }
                }
                if let Some(node_id) = can["iroh_node_id"].as_str() {
                    arms.push(Arm {
                        label: format!("{} {}", short_name, side),
                        node_id: node_id.to_string(),
                    });
                }
            }
        }
    }

    Ok(arms)
}

fn main() -> Result<()> {
    let args: Vec<String> = std::env::args().collect();

    let filter_host = args.get(1).map(|s| s.as_str());
    let filter_side = args.get(2).map(|s| s.as_str());

    let arms = load_arms(filter_host, filter_side)?;

    if arms.is_empty() {
        println!("No arms found. Run scripts/fetch-machines.sh first.");
        if let Some(h) = filter_host {
            println!(
                "Filter: host={}{}",
                h,
                filter_side
                    .map(|s| format!(" side={}", s))
                    .unwrap_or_default()
            );
        }
        return Ok(());
    }

    println!("Disabling torque on {} arm(s)...", arms.len());

    for arm in &arms {
        print!("  {} ... ", arm.label);
        match socketcan::new(&arm.node_id)
            .timeout(Duration::from_secs(10))
            .open()
        {
            Ok(mut socket) => {
                for motor_id in 0x01..=0x08u32 {
                    let frame = socketcan::CanFrame::new(motor_id, &DISABLE_MIT)?;
                    socket.write_frame(&frame)?;
                }
                println!("disabled");
            }
            Err(e) => {
                println!("FAILED: {}", e);
            }
        }
    }

    println!("Done.");
    Ok(())
}
